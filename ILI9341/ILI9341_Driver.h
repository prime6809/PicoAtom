
//	MIT License
//
//	Copyright (c) 2017 Matej Artnak
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//	copies of the Software, and to permit persons to whom the Software is
//	furnished to do so, subject to the following conditions:
//
//	The above copyright notice and this permission notice shall be included in all
//	copies or substantial portions of the Software.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//	SOFTWARE.
//
//
//
//-----------------------------------
//	ILI9341 Driver library for STM32
//-----------------------------------
//
//	While there are other libraries for ILI9341 they mostly require either interrupts, DMA or both for fast drawing
//	The intent of this library is to offer a simple yet still reasonably fast alternatives for those that
//	do not wish to use interrupts or DMA in their projects.
//
//	Library is written for STM32 HAL library and supports STM32CUBEMX. To use the library with Cube software
//	you need to tick the box that generates peripheral initialization code in their own respective .c and .h file
//
//
//-----------------------------------
//	Performance
//-----------------------------------
//	Settings:	
//	--SPI @ 50MHz 
//	--STM32F746ZG Nucleo board
//	--Redraw entire screen
//
//	++		Theoretical maximum FPS with 50Mhz SPI calculated to be 40.69 FPS
//	++		320*240 = 76800 pixels, each pixel contains 16bit colour information (2x8)
//	++		Theoretical Max FPS: 1/((320*240*16)/50000000)
//
//	With ART Accelerator, instruction prefetch, CPI ICACHE and CPU DCACHE enabled:
//
//	-FPS:									39.62
//	-SPI utilization:			97.37%
//	-MB/Second:						6.09
//
//	With ART Accelerator, instruction prefetch, CPI ICACHE and CPU DCACHE disabled:
//
//	-FPS:									35.45
//	-SPI utilization:			87.12%
//	-MB/Second:						5.44
//	
//	ART Accelerator, instruction prefetch, CPI ICACHE and CPU DCACHE settings found in MXCUBE under "System-> CORTEX M7 button"
//
//
//
//-----------------------------------
//	How to use this library
//-----------------------------------
//
//	-generate SPI peripheral and 3 GPIO_SPEED_FREQ_VERY_HIGH GPIO outputs
//	 		++Library reinitializes GPIOs and SPIs generated by gpio.c/.h and spi.c/.h using MX_X_Init(); calls
//			++reinitialization will not clash with previous initialization so generated initializations can be laft as they are
//	-If using MCUs other than STM32F7 you will have to change the #include "stm32f7xx_hal.h" in the ILI9341_STM32_Driver.h to your respective .h file
//	-define your HSPI_INSTANCE in ILI9341_STM32_Driver.h
//	-define your CS, DC and RST outputs in ILI9341_STM32_Driver.h
//	-check if ILI9341_SCREEN_HEIGHT and ILI9341_SCREEN_WIDTH match your LCD size
//			++Library was written and tested for 320x240 screen size. Other sizes might have issues**
//	-in your main program initialize LCD with ILI9341_Init();
//	-library is now ready to be used. Driver library has only basic functions, for more advanced functions see ILI9341_GFX library	
//
//-----------------------------------
//
// Ported to run on Raspbery Pi Pico
//
// 2021-06, Phill Harvey-Smith.
//

#include "delays.h"
#include "status.h"
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include "pico/stdlib.h"
#include "pico/binary_info.h"
#include "hardware/spi.h"

#ifndef ILI9341_STM32_DRIVER_H
#define ILI9341_STM32_DRIVER_H

extern uint8_t DebugEnabled;

// Set to 1 to compile for SPI interface, 0 for parallel.
#define ILI9341_USE_SPI	1

#if ILI9341_USE_SPI == 1
// Set to 1 to use DMA based scrolling/filling etc when using the SPI in interface as it's *MUCH* faster.
#define ILI9341_USE_DMA		1

// Set this to the SPI port number you want to use 1..2 for Pi Pico
#define ILI9341_SPI_PORT	1

// Set this to 1 to use the port remapping on some SPI ports, if supported.
#define ILI9341_SPI_REMAP	0

#if ILI9341_SPI_PORT == 1
#if ILI9341_SPI_REMAP == 0

#define ILI9341_SPI_SCK		2
#define ILI9341_SPI_MISO	4
#define ILI9341_SPI_MOSI	3
#define ILI9341_SPI_CS		5
#define ILI9341_SPI_CD		6
#define ILI9341_RESET		7
#else
#define ILI9341_SPI_SCK		6
#define ILI9341_SPI_MISO	8
#define ILI9341_SPI_MOSI	7
#define ILI9341_SPI_CS		9
#define ILI9341_SPI_CD		10
#define ILI9341_RESET		11
#endif

#define ILI9341_SPI			spi0
#define ILI9341_CLK_EN		LL_APB2_GRP1_PERIPH_SPI1

#define ILI9341_DMA_CH_IN	2
#define ILI9341_DMA_CH_OUT	3
#define ILI9341_DMA_CTRL	DMA1

#elif ILI9341_SPI_PORT == 2
// SPI2 cannot be remapped
/**SPI2 GPIO Configuration
 PB13   ------> SPI2_SCK
 PB14   ------> SPI2_MISO
 PB15   ------> SPI2_MOSI
*/
#define ILI9341_SPI_SCK		10
#define ILI9341_SPI_MISO	12
#define ILI9341_SPI_MOSI	11
#define ILI9341_SPI_CS		13
#define ILI9341_SPI_CD		14
#define ILI9341_RESET		15

#define ILI9341_SPI			spi1

#define ILI9341_DMA_CH_IN	4
#define ILI9341_DMA_CH_OUT	5
#define ILI9341_DMA_CTRL	DMA1
#endif

#else
#define ILI9341_USE_DMA	0
#endif

#if (ILI9341_USE_SPI == 0)
// Pins / port to be used for parallel bus, this works better if the group of pins is
// either the top 8 or bottom 8 as this allows us to configure the data direction
// with a single register access, having the pins straddling the two halves would
// mean that 2 register accesses where required, this is obviously less efficient.

#define	ILIDataPort		GPIOC
#define ILIDataPins		(DB0_Pin | DB1_Pin | DB2_Pin | DB3_Pin | DB4_Pin | DB5_Pin | DB6_Pin | DB7_Pin)
#define ILIDataMask		0x00FF

#define ILIInDataReg	ILIDataPort->IDR
#define ILIOutDataReg	ILIDataPort->ODR
#define ILISetBitReg	ILIDataPort->BSRR
#define ILIResetBitReg	ILIDataPort->BRR
#define ILICtrlReg		ILIDataPort->CRL

// all bits floating input
//#define ILICtrlModeI	0x44444444
#define ILICtrlModeI	0x88888888

// All bits output, 10MHz max, push-pull
//#define ILICtrlModeO	0x11111111
#define ILICtrlModeO	0x33333333

#define ILIPortReadMode()	ILICtrlReg = ILICtrlModeI
#define ILIPortWriteMode()	ILICtrlReg = ILICtrlModeO

// Set/Clear the /RD and /WR pins to the display, only used in parallel mode
#define ILISetReadMode()	LL_GPIO_ResetOutputPin(nRD_IL9341_GPIO_Port, nRD_IL9341_Pin)
#define ILISetWriteMode()	LL_GPIO_ResetOutputPin(nWR_IL9341_GPIO_Port, nWR_IL9341_Pin)
#define ILIClearReadMode()	LL_GPIO_SetOutputPin(nRD_IL9341_GPIO_Port, nRD_IL9341_Pin)
#define ILIClearWriteMode()	LL_GPIO_SetOutputPin(nWR_IL9341_GPIO_Port, nWR_IL9341_Pin)

#endif 

#define ILI9341_SCREEN_HEIGHT 	240
#define ILI9341_SCREEN_WIDTH 	320

// SetCommand and SetData tell the LCD if we are sending commands or data to it
// Typically we would SetCommand, send the command byte, then SetData and send / recieve
// one or more data bytes (if the command has parameters / replies).
#define ILISetCommand()		do {asm volatile("nop \n nop \n nop");  gpio_put(ILI9341_SPI_CD, 0); asm volatile("nop \n nop \n nop");}while(0)
#define ILISetData()		do {asm volatile("nop \n nop \n nop");  gpio_put(ILI9341_SPI_CD, 1); asm volatile("nop \n nop \n nop");}while(0)

// Select and deselect display, note deselecting always puts the display back in command mode.
#define ILISelect()			do { asm volatile("nop \n nop \n nop");  gpio_put(ILI9341_SPI_CS, 0); asm volatile("nop \n nop \n nop"); } while (0)
#define ILIDeSelect()		do { asm volatile("nop \n nop \n nop"); gpio_put(ILI9341_SPI_CS, 1); asm volatile("nop \n nop \n nop"); ILISetCommand(); } while (0)

// Assert or release the display's reset line
#define ILISetReset()		do { asm volatile("nop \n nop \n nop");  gpio_put(ILI9341_RESET, 0); asm volatile("nop \n nop \n nop"); } while (0)
#define ILIClearReset()		do { asm volatile("nop \n nop \n nop");  gpio_put(ILI9341_RESET, 1); asm volatile("nop \n nop \n nop"); } while (0)

// Read or write data to the display's parallel bus.
#define ILIReadData()		(ILIInDataReg & ILIDataMask)
#define ILIWriteData(data)	do { ILISetBitReg = (data & ILIDataMask); ILIResetBitReg = (data ^ ILIDataMask); } while (0)

// Quick command macro to set the pixel format, by sending LCD_PIXEL_FORMAT command and it's parameter
#define SetPixelFormat(fmt)	do { ILISelect(); ILI9341_Write_Command(LCD_PIXEL_FORMAT); ILI9341_Write_Data(fmt); } while (0)

#define ILICommand	0
#define ILIData		1

#define BURST_MAX_SIZE 	10240

// Colour definitions

#define BLACK       0x0000      
#define NAVY        0x000F      
#define DARKGREEN   0x03E0      
#define DARKCYAN    0x03EF      
#define MAROON      0x7800      
#define PURPLE      0x780F      
#define OLIVE       0x7BE0      
#define LIGHTGREY   0xC618      
#define DARKGREY    0x7BEF      
#define BLUE        0x001F      
#define GREEN       0x07E0      
#define CYAN        0x07FF      
#define RED         0xF800     
#define MAGENTA     0xF81F      
#define YELLOW      0xFFE0      
#define WHITE       0xFFFF      
#define ORANGE      0xFD20      
#define GREENYELLOW 0xAFE5     
#define PINK        0xF81F

/* Level 1 Commands */
#define LCD_NOP					0x00
#define LCD_SWRESET             0x01   /* Software Reset */
#define LCD_READ_DISPLAY_ID     0x04   /* Read display identification information */
#define LCD_RDDST               0x09   /* Read Display Status */
#define LCD_RDDPM               0x0A   /* Read Display Power Mode */
#define LCD_RDDMADCTL           0x0B   /* Read Display MADCTL */
#define LCD_RDDCOLMOD           0x0C   /* Read Display Pixel Format */
#define LCD_RDDIM               0x0D   /* Read Display Image Format */
#define LCD_RDDSM               0x0E   /* Read Display Signal Mode */
#define LCD_RDDSDR              0x0F   /* Read Display Self-Diagnostic Result */
#define LCD_SPLIN               0x10   /* Enter Sleep Mode */
#define LCD_SLEEP_OUT           0x11   /* Sleep out register */
#define LCD_PTLON               0x12   /* Partial Mode ON */
#define LCD_NORMAL_MODE_ON      0x13   /* Normal Display Mode ON */
#define LCD_DINVOFF             0x20   /* Display Inversion OFF */
#define LCD_DINVON              0x21   /* Display Inversion ON */
#define LCD_GAMMA               0x26   /* Gamma register */
#define LCD_DISPLAY_OFF         0x28   /* Display off register */
#define LCD_DISPLAY_ON          0x29   /* Display on register */
#define LCD_COLUMN_ADDR         0x2A   /* Colomn address register */
#define LCD_PAGE_ADDR           0x2B   /* Page address register */
#define LCD_RAMWR               0x2C   /* GRAM Memory write */
#define LCD_RGBSET              0x2D   /* Color SET */
#define LCD_RAMRD               0x2E   /* GRAM Memory Read */
#define LCD_PLTAR               0x30   /* Partial Area */
#define LCD_VSCRDEF             0x33   /* Vertical Scrolling Definition */
#define LCD_TEOFF               0x34   /* Tearing Effect Line OFF */
#define LCD_TEON                0x35   /* Tearing Effect Line ON */
#define LCD_MAC                 0x36   /* Memory Access Control register*/
#define LCD_VSCRSADD            0x37   /* Vertical Scrolling Start Address */
#define LCD_IDMOFF              0x38   /* Idle Mode OFF */
#define LCD_IDMON               0x39   /* Idle Mode ON */
#define LCD_PIXEL_FORMAT        0x3A   /* Pixel Format register */
#define LCD_WRITE_MEM_CONTINUE  0x3C   /* Write Memory Continue */
#define LCD_READ_MEM_CONTINUE   0x3E   /* Read Memory Continue */
#define LCD_SET_TEAR_SCANLINE   0x44   /* Set Tear Scanline */
#define LCD_GET_SCANLINE        0x45   /* Get Scanline */
#define LCD_WDB                 0x51   /* Write Brightness Display register */
#define LCD_RDDISBV             0x52   /* Read Display Brightness */
#define LCD_WCD                 0x53   /* Write Control Display register*/
#define LCD_RDCTRLD             0x54   /* Read CTRL Display */
#define LCD_WRCABC              0x55   /* Write Content Adaptive Brightness Control */
#define LCD_RDCABC              0x56   /* Read Content Adaptive Brightness Control */
#define LCD_WRITE_CABC          0x5E   /* Write CABC Minimum Brightness */
#define LCD_READ_CABC           0x5F   /* Read CABC Minimum Brightness */
#define LCD_READ_ID1            0xDA   /* Read ID1 */
#define LCD_READ_ID2            0xDB   /* Read ID2 */
#define LCD_READ_ID3            0xDC   /* Read ID3 */

/* Level 2 Commands */
#define LCD_RGB_INTERFACE       0xB0   /* RGB Interface Signal Control */
#define LCD_FRMCTR1             0xB1   /* Frame Rate Control (In Normal Mode) */
#define LCD_FRMCTR2             0xB2   /* Frame Rate Control (In Idle Mode) */
#define LCD_FRMCTR3             0xB3   /* Frame Rate Control (In Partial Mode) */
#define LCD_INVTR               0xB4   /* Display Inversion Control */
#define LCD_BPC                 0xB5   /* Blanking Porch Control register */
#define LCD_DFC                 0xB6   /* Display Function Control register */
#define LCD_ETMOD               0xB7   /* Entry Mode Set */
#define LCD_BACKLIGHT1          0xB8   /* Backlight Control 1 */
#define LCD_BACKLIGHT2          0xB9   /* Backlight Control 2 */
#define LCD_BACKLIGHT3          0xBA   /* Backlight Control 3 */
#define LCD_BACKLIGHT4          0xBB   /* Backlight Control 4 */
#define LCD_BACKLIGHT5          0xBC   /* Backlight Control 5 */
#define LCD_BACKLIGHT7          0xBE   /* Backlight Control 7 */
#define LCD_BACKLIGHT8          0xBF   /* Backlight Control 8 */
#define LCD_POWER1              0xC0   /* Power Control 1 register */
#define LCD_POWER2              0xC1   /* Power Control 2 register */
#define LCD_VCOM1               0xC5   /* VCOM Control 1 register */
#define LCD_VCOM2               0xC7   /* VCOM Control 2 register */
#define LCD_NVMWR               0xD0   /* NV Memory Write */
#define LCD_NVMPKEY             0xD1   /* NV Memory Protection Key */
#define LCD_RDNVM               0xD2   /* NV Memory Status Read */
#define LCD_READ_ID4            0xD3   /* Read ID4 */
#define LCD_PGAMMA              0xE0   /* Positive Gamma Correction register */
#define LCD_NGAMMA              0xE1   /* Negative Gamma Correction register */
#define LCD_DGAMCTRL1           0xE2   /* Digital Gamma Control 1 */
#define LCD_DGAMCTRL2           0xE3   /* Digital Gamma Control 2 */
#define LCD_INTERFACE           0xF6   /* Interface control register */

// Undocumeneted read parameter command

#define LCD_READREG				0xD9	/* Not documented on the datasheet! */
#define LCD_READREG_MAGIC		0x10	/* Magic parameter for above command */

/* Extend register commands */
#define LCD_POWERA               0xCB   /* Power control A register */
#define LCD_POWERB               0xCF   /* Power control B register */
#define LCD_DTCA                 0xE8   /* Driver timing control A */
#define LCD_DTCB                 0xEA   /* Driver timing control B */
#define LCD_POWER_SEQ            0xED   /* Power on sequence register */
#define LCD_3GAMMA_EN            0xF2   /* 3 Gamma enable register */
#define LCD_PRC                  0xF7   /* Pump ratio control register */

// Pixel formats, the _IF and _RGB can be or'd together
#define PX_16_IF				0x05	/* 16 bits / pixel external interface */
#define PX_18_IF				0x06	/* 18 bits / pixel external interface */
#define PX_16_RGB				0x50	/* 16 bits / pixel RGB interface */
#define PX_18_RGB				0x60	/* 18 bits / pixel RGB interface */

#define PX_DEFAULT				PX_16_IF | PX_16_RGB

typedef struct
{
	uint8_t	Red;
	uint8_t	Green;
	uint8_t	Blue;
} rgb_t;

// Symbolic constants for the display's Memory access register, these define how the display's
// RAM is mapped to the actual pixels, and allow the display to be oriented in one of 4
// different directions (L->R, R->L, T->B, B->T).
#define	MAC_MY					0x80	/* Row address order 0=Top->Bot, 1=Bot->Top */
#define MAC_MX					0x40	/* Column address order 0=L->R 1=R->L*/
#define MAC_MV					0x20	/* Row / Column exchange 0=normal, 1=reverse*/
#define MAC_ML					0x10	/* LCD vertical refresh direction 0=Top->Bot, 1=Bot->Top */
#define MAC_BGR					0x08	/* colour byte order, 0=RGB, 1=BGR */
#define MAC_MH					0x04	/* LCD horizontal refresh direction 0=L->R 1=R->L*/
#define MAC_VALID_MASK			(MAC_MY | MAC_MX | MAC_MV | MAC_ML | MAC_BGR | MAC_MH)

#define RGBto565(r,g,b)			(uint16_t )((r & 0x1F) << 10) | ((g & 0x3F) << 4) | (b & 0x1F)
#define RGBtoColour565(rgb)		(uint16_t )((rgb.Red & 0xF8) << 8) | ((rgb.Green & 0xFC) << 3) | (rgb.Blue >> 3)
#define BGRtoColour565(rgb)		(uint16_t )((rgb.Blue & 0xF8) << 8) | ((rgb.Green & 0xFC) << 3) | (rgb.Red >> 3)

#define SwapColour(colour)		(uint16_t)((colour >> 8) | (colour << 8))

/* Size of read registers */
#define LCD_READ_ID4_SIZE        3      /* Size of Read ID4 */

// Screen orientations for ILI9341_Set_Rotation
#define SCREEN_VERTICAL_1		0
#define SCREEN_HORIZONTAL_1		1
#define SCREEN_VERTICAL_2		2
#define SCREEN_HORIZONTAL_2		3

// Current screen width and height, these are updated by ILI9341_Set_Rotation
extern volatile uint16_t LCD_HEIGHT;
extern volatile uint16_t LCD_WIDTH;

// Function prototypes
void ILI9341_Init(uint baudrate);
void ILI9341_Send(unsigned char SPI_Data);
uint8_t ILI9341_Get(void);
void ILI9341_TransmitCD(uint8_t *Buff, uint16_t Size, uint8_t	CmdData);
void ILI9341_Transmit(uint8_t *Buff, uint16_t Size);
void ILI9341_Receive(uint8_t *Buff, uint16_t Size);
void ILI9341_Receive_RGB(uint16_t *Buff, uint16_t Pixels);

void ILI9341_Write_Command(uint8_t Command);
void ILI9341_Write_Data(uint8_t Data);
void ILI9341_Write_DataMulti(uint8_t *Data, int Size);
void ILI9341_Write_Command_Get(uint8_t Command, uint8_t *Buff, uint16_t Size);
void ILI9341_Write_Command_Put(uint8_t Command, uint8_t *Buff, uint16_t Size);
uint8_t	ILI9341_Read_Data(void);

void ILI9341_Set_AddressRW(uint16_t X1, uint16_t Y1, uint16_t X2, uint16_t Y2, uint8_t IsWrite);
uint8_t ILI9341_ReadReg(uint8_t Reg, uint8_t ParamByteNo);
uint8_t ILI9341_ReadReg2(uint8_t Reg, uint8_t ParamByteNo);


void ILI9341_Reset(void);
void ILI9341_Set_Rotation(uint8_t Rotation);
void ILI9341_Fill_Screen(uint16_t Colour);
void ILI9341_Draw_Colour(uint16_t Colour);
void ILI9341_Draw_Pixel(uint16_t X,uint16_t Y,uint16_t Colour);
void ILI9341_Draw_Colour_Burst(uint16_t Colour, uint32_t Size);

void ILI9341_Draw_Rectangle(uint16_t X, uint16_t Y, uint16_t Width, uint16_t Height, uint16_t Colour);
void ILI9341_Draw_Horizontal_Line(uint16_t X, uint16_t Y, uint16_t Width, uint16_t Colour);
void ILI9341_Draw_Vertical_Line(uint16_t X, uint16_t Y, uint16_t Height, uint16_t Colour);

void ILI9341_ReadID(uint8_t *buff);

void ILI9341_DebugParams(void);
#endif

